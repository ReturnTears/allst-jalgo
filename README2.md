# 秒懂算法

## Chapter 3
```text
◆ 本书网址是https://pragprog.com/titles/jwdsal2

第1章 数据结构为何重要

◆ 高质量代码还有另一个特征，那就是代码的效率

1.1 数据结构

◆ 数据是一个宽泛的术语，可以指代所有类型的信息。最基本的数据就是数和字符串

◆ 数据结构指的是数据的组合方式

◆ 数据结构不仅仅是数据的组合方式，还会极大地影响代码运行速度


1.2 数组：基础数据结构

◆ 数组是计算机科学中最基本的数据结构之一

◆ 数组大小指的是数组能存放的数据元素的数量

◆ 数组的索引可以用来标记数据在数组中的位置。

◆ 读取：从数据结构的特定位置查看某数据。对数组来说，就是查看特定索引的值

◆ 查找：寻找数据结构中的特定值。对数组来说，就是检查数组中是否存在这个值

◆ 插入：向数据结构中添加新的值。对数组来说，就是给数组增加一个位置，在里面添加一个新值

◆ 删除：从数据结构中移除一个值。对数组来说，这意味着把其中一项移除


1.3 速度计量

◆ 衡量操作的速度也被称作衡量其时间复杂度


1.4 读取

◆ 计算机从数组中读取仅需要1步。这是因为计算机有能力跳到任意索引的位置，并检查它的值

◆ 计算机内存的每个格子都有一个地址

◆ 当计算机读取数组中某一索引的值时，能直接跳转到那个索引

◆ 计算机可以一步跳转到任意内存地址。

◆ 当计算机将内存分配给数组时，它会记录数组从哪个内存地址开始

◆ 因为计算机读取任意索引只需要跳转到其内存地址这一步，所以数组读取是一个高效的操作


1.5 查找

◆ 查找意味着判断数组中是否存在特定值。如果存在，那么查找操作还要给出它的索引。

◆ 在某种意义上，查找与读取正好相反。读取是给计算机提供一个索引，并让它返回位于该索引的值。查找则是给计算机提供一个值，并让它返回那个值的索引。

◆ 虽然这两个操作听起来类似，但效率有着天壤之别。因为计算机能跳转到任意索引并找到它的值，所以从一个索引读取值很快。但查找就麻烦多了，因为计算机不能跳转到特定值

◆ 这是计算机的一个重要特性：可以立刻访问所有内存地址，但它事先不知道每个内存地址存储的值

◆ 上述这种一次检查一个格子的基本查找操作称为线性查找。

◆ 线性查找一个数组最多需要多少步呢？

◆ 如果要找的值刚好在数组的最后一个格子里（比如"elderberries"）​，那么计算机就必须检查数组的每一个格子。如果数组中根本没有要找的值，那么计算机同样需要检查每一个格子，才能确定这个值不在数组中

◆ 对于有N个格子的数组，线性查找最多需要N步

◆ 查找都不如读取效率高。这是因为查找可能需要很多步，而读取任意大小的数组都只需要1步。


1.6 插入

◆ 向数组中插入数据的效率取决于你想要插入的位置。

◆ 向数组开头插入元素需要步数最多，也就是所谓的最坏情况。这是因为要在数组开头插入元素，必须把其他所有值都右移一个格子。

◆ 对包含N个元素的数组来说，最坏的情况下需要N + 1步插入。这是因为需要移动N个元素，然后才能执行插入操作。


1.7 删除

◆ 删除指的是删去特定索引的值的过程。

◆ 删除元素的最坏情况是删除数组中的第一个元素。因为索引0会变成空格子，所以必须把剩余的所有元素都左移。

◆ 对于有N个元素的数组，删除操作最多需要N步


1.8 集合：差之毫厘，“慢”之千里

◆ 集合。集合中包含的元素不能重复。

◆ 集合的读取和数组的读取完全一致，即计算机检查特定索引处的值只需要1步

◆ 这是因为计算机能跳转到集合内的任意索引，而这只需简单地计算并跳转到其内存地址即可。

◆ 集合的查找也和数组的查找没什么区别，即查找集合中的值最多需要N步。集合和数组的删除操作也一模一样，即要删除一个值并移动其他数据来填空最多需要N步

◆ 计算机要如何确保新数据不在集合中呢？记住，计算机一开始并不知道数组或者集合的格子中存储了什么值。因此，它必须先在集合中查找，才能知道要插入的值是否已经存在。只有集合中不存在这个新值的时候，计算机才能继续执行插入操作。

◆ 所有的插入操作都需要先进行查找。

◆ 对包含N个元素的集合来说，在集合末尾插入值最多需要N +1步。这是因为确定集合中不含该值需要N步，而实际的插入还需要1步。数组的相同操作则只需要1步。

◆ 向集合开头插入值是最坏的情况。为此，计算机需要先查找N个格子来确保该值不在集合中，然后再用N步来右移全部数据，最后再用1步来插入新值。全部加起来是2N +1步。数组的相同操作则只需要N +1步。


第2章 算法为何重要

◆ 算法就是完成特定任务所需的一组操作。

◆ 对计算机来说，算法指的是计算机为完成特定任务所执行的一组指令。写代码就是创造算法以让计算机执行的过程。


2.1 有序数组

◆ 有序数组和第1章中的“传统”数组几乎完全一致。你也能猜到，它们唯一的区别在于有序数组中的值是按顺序排列的。也就是说，插入新值时，这个值必须被放到一个合适的格子中，以免打乱数组的顺序。

◆ 有趣的是，在有序数组中，无论新值最后插到哪里，所需的步骤数都差不多。如果这个值最后位于数组开头，那么所需的比较就更少，移动就更多。如果它最后位于数组末尾，那么比较就更多，移动就更少。当新值位于数组的最末尾时，因为不需要移动任何数据，所以总共需要的步骤数就最少。在此情况下，和N个现有的值比较需要N步，而插入本身还需要1步，因此，共计为N+1步


2.2 有序数组的查找

◆ 在传统数组中查找特定值的过程：从左向右，依次检查每个格子，直至找到这个值。我当时把这个过程叫作线性查找

◆ 与传统数组相比，有序数组的优势就在于可以用另一个查找算法。这就是二分查找，它比线性查找要快得多。


2.3 二分查找

◆ 注意，只有在有序数组中才能进行二分查找。传统数组中的值未必按顺序排列，我们无法知道到底该往左边还是右边进行查找。这就是有序数组的优势之一：可以使用二分查找。


2.4 二分查找与线性查找

◆ 来和线性查找对比一下。如果你有3个元素，那么最多需要3步。7个元素最多需要7步，100个元素最多需要100步。对线性查找来说，有多少个元素就有多少步。每次加倍数据量，查找的步骤数也要加倍。而二分查找在加倍数据量时，只需要多1步。

衡量算法效率的主要指标就是算法需要的步骤数。

3.1 大O：对N个元素来说需要多少步

◆ 核心问题的答案就在大O表达式的圆括号中。O(N)意味着核心问题的答案是“算法需要N步”。

量化线性查找效率的更有效的方法，就是说它查找数组中的 N 个元素需要 N 步。换言之，如果数组中有 N 个元素，那么线性查找就需要 N 步。

为了让时间复杂度的讨论更简单，计算机科学家从数学世界借用了一个概念。借助这个概念，数据结构和算法的效率表述可以更简洁、更统一。
这个概念就是大 O 记法。这种正式表述让我们可以轻松地把算法按照效率分门别类，并与人交流。

大 O 用一种特别的方法关注算法需要的步骤数，借此达成一致性。我们先用大 O 分析线性查找算法。
在最坏的情况下，数组中有多少个元素，线性查找就需要多少步。对于有 N个元素的数组，线性查找最多需要 N 步。用大 O 记法来表示就是：O(N)。
这个记法表述了一个“核心问题”的答案。这个核心问题就是：如果有 N 个数据元素，那么算法需要多少步？
核心问题的答案就在大 O表达式的圆括号中。O(N)意味着核心问题的答案是“算法需要 N 步”。

时间复杂度 O(N)的算法也被称为线性时间算法。

无论数组有多大，读取都只需要 1步。想用大 O记法表示这个复杂度，还需从核心问题开始：如果有 N个数据元素，那么从数组中读取需要多少步呢？因为答案是 1，所以写成 O(1)。我把它读作“O1”。

O(1)非常有趣，因为虽然核心问题和 N 有关（“如果有 N 个数据元素，那么算法需要多少步？”），
但是答案和 N 无关。这就是重点所在。换言之，无论数组中有多少个数据元素，从数组中读取总是需要 1 步。

这就是 O(1)被认为是“最快”的一类算法的原因。即便数据量增加，O(1)算法也不需要额外的步骤。
无论 N 是多少，O(1)算法的步骤数都是固定的。事实上，O(1)算法也被称作常数时间算法。

3.2 大O的灵魂

◆ 大O确实表示算法对于N个数据元素需要的步骤数，但这种说法没有涵盖大O背后更深一层的原因，我称之为“大O的灵魂”​。

◆ 大O的灵魂才是其真正含义：随着数据的增加，算法性能会如何变化？

◆ 大O不仅会告诉你算法需要的步骤数，还会告诉你数据变化时步骤数的变化。


3.3 第三类算法

◆ 二分查找看起来位于O(1)和O(N)的中间。那它的复杂度到底是什么呢？

◆ 用大O记法，我们会说二分查找的时间复杂度是O(log N)

◆ 我把它读作“O log N”。这种算法也被称为对数时间算法

◆ O(log N)描述了这样一类算法：数据量每翻一番，步骤数都增加1

◆ O(log N)的曲线只是稍稍上扬，虽然没有O(1)高效，但还是比O(N)好得多


3.4 对数

◆ 对数是指数的反函数


3.5 O(log N)的含义

◆ 计算机科学中说的O(log N)其实就是O(log2N)的缩写。为了方便使用，我们省略了2

◆ O(log N)的意思是，对于N个数据元素，算法需要log2N步。如果有8个元素，因为log28 = 3，所以算法需要3步。
换言之，如果一直把8个元素等分，那么需要3步才能得到1个元素





```
